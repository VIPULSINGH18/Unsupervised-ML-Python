# -*- coding: utf-8 -*-
"""Clustering(Unsupervised_learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14usv-_aCL50fJ8TZeL7PlJ3G-hpk6W-L
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

#make blob is used to create a dataset witvh given samples (rows)
x,y_true= make_blobs(n_samples=500,centers=3,cluster_std=0.60,random_state=42)

#as this is unsupervised learning so we need only input feature x for model building..
df= pd.DataFrame(x,columns=['Feature_1','Feature_2'])

df

scaler= StandardScaler()
x_scaled= scaler.fit_transform(x)

#using elbow method to define the value of k which tells us how many cluster we have to build...
inertia=[]
k_range= range(1,11)

for k in k_range:
  kmeans= KMeans(n_clusters=k,random_state=42)
  kmeans.fit(x_scaled)
  inertia.append(kmeans.inertia_)  #k_means.inertia_ this function is used to give the wcss value of our mode...

plt.plot(k_range,inertia,marker='o')

#now from here we can see that the point from where gradual decrease stopped that point will be our k value....

kmeans_final= KMeans(n_clusters=3,random_state=42)

cluster_labels= kmeans_final.fit_predict(x_scaled)
df['cluster']= cluster_labels

sns.scatterplot(x=df['Feature_1'],y=df['Feature_2'],hue=df['cluster'],palette='viridis')

#hence now our kmeans_cluster model is prepared....

#now we will both kmeans and dbscan algo over make_moon dataset to
#predict the difference...

from sklearn.datasets import make_moons

x,y_true= make_moons(n_samples=500,noise=0.05,random_state=42)

from sklearn.cluster import KMeans,DBSCAN

df= pd.DataFrame(x,columns=['Feature_1','Feature_2'])

df

scaler= StandardScaler()
x_scaled= scaler.fit_transform(df)

kmeans= KMeans(n_clusters=2,random_state=42)
kmeans_label= kmeans.fit_predict(x_scaled)

df['kmeans_cluster']= kmeans_label

df

sns.scatterplot(x=df['Feature_1'],y=df['Feature_2'],hue=df['kmeans_cluster'],palette='tab10')

#now the problem arises as make_moons is not circular data so thats why
#kmean gives such kind of cluster which is not appropriate

#Thats why DB scan came into role...

db_scan= DBSCAN(eps=0.2,min_samples=5)

db_scan_labels= db_scan.fit_predict(x_scaled)

df['dbscan_labels']= db_scan_labels

df

sns.scatterplot(x=df['Feature_1'],y=df['Feature_2'],hue=df['dbscan_labels'],palette='tab10')

